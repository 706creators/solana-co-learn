"use strict";(self.webpackChunkall_in_one_solana=self.webpackChunkall_in_one_solana||[]).push([[5521],{3905:(n,t,e)=>{e.d(t,{Zo:()=>u,kt:()=>h});var a=e(67294);function o(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function i(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){o(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function c(n,t){if(null==n)return{};var e,a,o=function(n,t){if(null==n)return{};var e,a,o={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(o[e]=n[e]);return o}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(o[e]=n[e])}return o}var l=a.createContext({}),s=function(n){var t=a.useContext(l),e=t;return n&&(e="function"==typeof n?n(t):i(i({},t),n)),e},u=function(n){var t=s(n.components);return a.createElement(l.Provider,{value:t},n.children)},p="mdxType",m={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(n,t){var e=n.components,o=n.mdxType,r=n.originalType,l=n.parentName,u=c(n,["components","mdxType","originalType","parentName"]),p=s(e),d=o,h=p["".concat(l,".").concat(d)]||p[d]||m[d]||r;return e?a.createElement(h,i(i({ref:t},u),{},{components:e})):a.createElement(h,i({ref:t},u))}));function h(n,t){var e=arguments,o=t&&t.mdxType;if("string"==typeof n||o){var r=e.length,i=new Array(r);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=n,c[p]="string"==typeof n?n:o,i[1]=c;for(var s=2;s<r;s++)i[s]=e[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,e)}d.displayName="MDXCreateElement"},79236:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var a=e(87462),o=(e(67294),e(3905));const r={title:"How interact with tokens in program",sidebar_position:31,tags:["solana-cook-book","game","token","program"]},i="Using tokens in games on Solana",c={unversionedId:"references/gaming/interact-with-tokens",id:"references/gaming/interact-with-tokens",title:"How interact with tokens in program",description:"Tokens on Solana can serve various purposes, such as in-game rewards, incentives, or other applications. For example, you can create tokens and distribute them to players when they complete specific in-game actions.",source:"@site/docs/cookbook-zh/references/gaming/interact-with-tokens.md",sourceDirName:"references/gaming",slug:"/references/gaming/interact-with-tokens",permalink:"/cookbook-zh/references/gaming/interact-with-tokens",draft:!1,editUrl:"https://github.com/CreatorsDAO/all-in-one-solana/tree/main/docs/cookbook-zh/references/gaming/interact-with-tokens.md",tags:[{label:"solana-cook-book",permalink:"/cookbook-zh/tags/solana-cook-book"},{label:"game",permalink:"/cookbook-zh/tags/game"},{label:"token",permalink:"/cookbook-zh/tags/token"},{label:"program",permalink:"/cookbook-zh/tags/program"}],version:"current",lastUpdatedBy:"Davirain",lastUpdatedAt:1695967092,formattedLastUpdatedAt:"Sep 29, 2023",sidebarPosition:31,frontMatter:{title:"How interact with tokens in program",sidebar_position:31,tags:["solana-cook-book","game","token","program"]},sidebar:"tutorialSidebar",previous:{title:"Energy System",permalink:"/cookbook-zh/references/gaming/energy-system"},next:{title:"Porting a program to Unity",permalink:"/cookbook-zh/references/gaming/porting-anchor-to-unity"}},l={},s=[{value:"Create, Mint, and Burn Tokens with Anchor",id:"create-mint-and-burn-tokens-with-anchor",level:2},{value:"Getting Started",id:"getting-started",level:3},{value:"Create Mint instruction",id:"create-mint-instruction",level:3},{value:"Init Player Instruction",id:"init-player-instruction",level:3},{value:"Kill Enemy Instruction",id:"kill-enemy-instruction",level:3},{value:"Heal Instruction",id:"heal-instruction",level:3},{value:"Build and Deploy",id:"build-and-deploy",level:3},{value:"Get Started with the Client",id:"get-started-with-the-client",level:3}],u={toc:s},p="wrapper";function m(n){let{components:t,...e}=n;return(0,o.kt)(p,(0,a.Z)({},u,e,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"using-tokens-in-games-on-solana"},"Using tokens in games on Solana"),(0,o.kt)("p",null,"Tokens on Solana can serve various purposes, such as in-game rewards, incentives, or other applications. For example, you can create tokens and distribute them to players when they complete specific in-game actions."),(0,o.kt)("h2",{id:"create-mint-and-burn-tokens-with-anchor"},"Create, Mint, and Burn Tokens with Anchor"),(0,o.kt)("p",null,"In this tutorial, we will build a game using Anchor to introduce the basics of interacting with the Token Program on Solana. The game will be structured around four main actions: creating a new token mint, initializing player accounts, rewarding players for defeating enemies, and allowing players to heal by burning tokens."),(0,o.kt)("p",null,"The program consists of 4 instructions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"create_mint"),' - This instruction creates a new token mint with a Program Derived Address (PDA) as the mint authority and creates the metadata account for the mint. We will add a constraint that allows only an "admin" to invoke this instruction'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"init_player")," - This instruction initializes a new player account with a starting health of 100"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"kill_enemy")," - This instruction deducts 10 health points from the player account upon \u201cdefeating an enemy\u201d and mints 1 token as a reward for the player"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"heal")," - This instruction allows a player to burn 1 token to restore their health back to 100")),(0,o.kt)("p",null,"For a high-level overview of the relationship among user wallets, token mints, token accounts, and token metadata accounts, consider exploring this portion of the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.metaplex.com/programs/token-metadata/overview"},"Metaplex documentation"),"."),(0,o.kt)("h3",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"To start building the program, follow these steps:"),(0,o.kt)("p",null,"Visit the ",(0,o.kt)("a",{parentName:"p",href:"https://beta.solpg.io/"},"Solana Playground")," and create a new Anchor project. If you're new to Solana Playground, you'll also need to create a Playground Wallet."),(0,o.kt)("p",null,"After creating a new project, replace the default starter code with the code below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    metadata::{create_metadata_accounts_v3, CreateMetadataAccountsV3, Metadata},\n    token::{burn, mint_to, Burn, Mint, MintTo, Token, TokenAccount},\n};\nuse mpl_token_metadata::{pda::find_metadata_account, state::DataV2};\nuse solana_program::{pubkey, pubkey::Pubkey};\n\ndeclare_id!("11111111111111111111111111111111");\n\n#[program]\npub mod anchor_token {\n    use super::*;\n}\n')),(0,o.kt)("p",null,"Here we are simply bringing into scope the crates and corresponding modules we will be using for this program. We\u2019ll be using the ",(0,o.kt)("inlineCode",{parentName:"p"},"anchor_spl")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mpl_token_metadata")," crates to help us interact with the Token program and the Token Metadata program."),(0,o.kt)("h3",{id:"create-mint-instruction"},"Create Mint instruction"),(0,o.kt)("p",null,"First, let\u2019s implement an instruction to create a new token mint and its metadata account. The on-chain token metadata, including the name, symbol, and URI, will be provided as parameters to the instruction."),(0,o.kt)("p",null,'Additionally, we\'ll only allow an "admin" to invoke this instruction by defining an ',(0,o.kt)("inlineCode",{parentName:"p"},"ADMIN_PUBKEY")," constant and using it as a constraint. Be sure to replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"ADMIN_PUBKEY")," with your Solana Playground wallet public key."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"create_mint")," instruction requires the following accounts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"admin")," - the ",(0,o.kt)("inlineCode",{parentName:"li"},"ADMIN_PUBKEY")," that signs the transaction and pays for the initialization of the accounts"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reward_token_mint")," - the new token mint we are initializing, using a PDA as both the mint account\u2019s address and its mint authority"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"metadata_account")," - the metadata account we are initializing for the token mint"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_program")," - required for interacting with instructions on the Token program"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_metadata_program")," - required account for interacting with instructions on the Token Metadata program"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"system_program"),"- a required account when creating a new account"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"rent")," - Sysvar Rent, a required account when creating the metadata account")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Only this public key can call this instruction\nconst ADMIN_PUBKEY: Pubkey = pubkey!("REPLACE_WITH_YOUR_WALLET_PUBKEY");\n\n#[program]\npub mod anchor_token {\n    use super::*;\n\n    // Create new token mint with PDA as mint authority\n    pub fn create_mint(\n        ctx: Context<CreateMint>,\n        uri: String,\n        name: String,\n        symbol: String,\n    ) -> Result<()> {\n        // PDA seeds and bump to "sign" for CPI\n        let seeds = b"reward";\n        let bump = *ctx.bumps.get("reward_token_mint").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // On-chain token metadata for the mint\n        let data_v2 = DataV2 {\n            name: name,\n            symbol: symbol,\n            uri: uri,\n            seller_fee_basis_points: 0,\n            creators: None,\n            collection: None,\n            uses: None,\n        };\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_metadata_program.to_account_info(),\n            CreateMetadataAccountsV3 {\n                metadata: ctx.accounts.metadata_account.to_account_info(), // the metadata account being created\n                mint: ctx.accounts.reward_token_mint.to_account_info(), // the mint account of the metadata account\n                mint_authority: ctx.accounts.reward_token_mint.to_account_info(), // the mint authority of the mint account\n                update_authority: ctx.accounts.reward_token_mint.to_account_info(), // the update authority of the metadata account\n                payer: ctx.accounts.admin.to_account_info(), // the payer for creating the metadata account\n                system_program: ctx.accounts.system_program.to_account_info(), // the system program account\n                rent: ctx.accounts.rent.to_account_info(), // the rent sysvar account\n            },\n            signer,\n        );\n\n        create_metadata_accounts_v3(\n            cpi_ctx, // cpi context\n            data_v2, // token metadata\n            true,    // is_mutable\n            true,    // update_authority_is_signer\n            None,    // collection details\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMint<\'info> {\n    #[account(\n        mut,\n        address = ADMIN_PUBKEY\n    )]\n    pub admin: Signer<\'info>,\n\n    // The PDA is both the address of the mint account and the mint authority\n    #[account(\n        init,\n        seeds = [b"reward"],\n        bump,\n        payer = admin,\n        mint::decimals = 9,\n        mint::authority = reward_token_mint,\n\n    )]\n    pub reward_token_mint: Account<\'info, Mint>,\n\n    ///CHECK: Using "address" constraint to validate metadata account address\n    #[account(\n        mut,\n        address=find_metadata_account(&reward_token_mint.key()).0\n    )]\n    pub metadata_account: UncheckedAccount<\'info>,\n\n    pub token_program: Program<\'info, Token>,\n    pub token_metadata_program: Program<\'info, Metadata>,\n    pub system_program: Program<\'info, System>,\n    pub rent: Sysvar<\'info, Rent>,\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"create_mint")," instruction creates a new token mint, using a Program Derived Address (PDA) as both the address of the token mint and its mint authority. The instruction takes a URI (off-chain metadata), name, and symbol as parameters."),(0,o.kt)("p",null,"This instruction then creates a metadata account for the token mint through a Cross-Program Invocation (CPI) calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_metadata_accounts_v3")," instruction from the Token Metadata program."),(0,o.kt)("p",null,'The PDA is used to "sign" the CPI since it is the mint authority, which is a required signer when creating the metadata account for a mint. The instruction data (URI, name, symbol) is included in the ',(0,o.kt)("inlineCode",{parentName:"p"},"DataV2")," struct to specify the new token mint's metadata."),(0,o.kt)("p",null,"We also verify that the address of the ",(0,o.kt)("inlineCode",{parentName:"p"},"admin")," account signing the transaction matches the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ADMIN_PUBKEY")," constant to ensure only the intended wallet can invoke this instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'const ADMIN_PUBKEY: Pubkey = pubkey!("REPLACE_WITH_YOUR_WALLET_PUBKEY");\n')),(0,o.kt)("h3",{id:"init-player-instruction"},"Init Player Instruction"),(0,o.kt)("p",null,"Next, let's implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"init_player")," instruction which creates a new player account with an initial health of 100. The constant ",(0,o.kt)("inlineCode",{parentName:"p"},"MAX_HEALTH")," is set to 100 to represent the starting health."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"init_player")," instruction requires the following accounts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player_data")," - the new player account we are initializing, which will store the player's health"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player")," - the user who signs the transaction and pays for the initialization of the account"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"system_program")," - a required account when creating a new account")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// Player max health\nconst MAX_HEALTH: u8 = 100;\n\n#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Create new player account\n    pub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct InitPlayer<'info> {\n    #[account(\n        init,\n        payer = player,\n        space = 8 + 8,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct PlayerData {\n    pub health: u8,\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"player_data")," account is initialized using a Program Derived Address (PDA) with the ",(0,o.kt)("inlineCode",{parentName:"p"},"player")," public key as one of the seeds. This ensures that each ",(0,o.kt)("inlineCode",{parentName:"p"},"player_data")," account is unique and associated with the ",(0,o.kt)("inlineCode",{parentName:"p"},"player"),", allowing every player to create their own ",(0,o.kt)("inlineCode",{parentName:"p"},"player_data")," account."),(0,o.kt)("h3",{id:"kill-enemy-instruction"},"Kill Enemy Instruction"),(0,o.kt)("p",null,"Next, let's implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"kill_enemy")," instruction which reduces the player's health by 10 and mints 1 token to the player's token account as a reward."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"kill_enemy")," instruction requires the following accounts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player")," - the player receiving the token"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player_data")," - the player data account storing the player\u2019s current health"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player_token_account")," - the player's associated token account where tokens will be minted"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reward_token_mint")," - the token mint account, specifying the type of token that will be minted"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_program")," - required for interacting with instructions on the token program"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"associated_token_program")," - required when working with associated token accounts"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"system_program")," - a required account when creating a new account")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Mint token to player token account\n    pub fn kill_enemy(ctx: Context<KillEnemy>) -> Result<()> {\n        // Check if player has enough health\n        if ctx.accounts.player_data.health == 0 {\n            return err!(ErrorCode::NotEnoughHealth);\n        }\n        // Subtract 10 health from player\n        ctx.accounts.player_data.health = ctx.accounts.player_data.health.checked_sub(10).unwrap();\n\n        // PDA seeds and bump to "sign" for CPI\n        let seeds = b"reward";\n        let bump = *ctx.bumps.get("reward_token_mint").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                to: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.reward_token_mint.to_account_info(),\n            },\n            signer,\n        );\n\n        // Mint 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct KillEnemy<\'info> {\n    #[account(mut)]\n    pub player: Signer<\'info>,\n\n    #[account(\n        mut,\n        seeds = [b"player".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<\'info, PlayerData>,\n\n    // Initialize player token account if it doesn\'t exist\n    #[account(\n        init_if_needed,\n        payer = player,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<\'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b"reward"],\n        bump,\n    )]\n    pub reward_token_mint: Account<\'info, Mint>,\n\n    pub token_program: Program<\'info, Token>,\n    pub associated_token_program: Program<\'info, AssociatedToken>,\n    pub system_program: Program<\'info, System>,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg("Not enough health")]\n    NotEnoughHealth,\n}\n')),(0,o.kt)("p",null,"The player's health is reduced by 10 to represent the \u201cbattle with the enemy\u201d. We\u2019ll also check the player's current health and return a custom Anchor error if the player has 0 health."),(0,o.kt)("p",null,"The instruction then uses a cross-program invocation (CPI) to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"mint_to")," instruction from the Token program and mints 1 token of the ",(0,o.kt)("inlineCode",{parentName:"p"},"reward_token_mint")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"player_token_account")," as a reward for killing the enemy."),(0,o.kt)("p",null,'Since the mint authority for the token mint is a Program Derived Address (PDA), we can mint tokens directly by calling this instruction without additional signers. The program can "sign" on behalf of the PDA, allowing token minting without explicitly requiring extra signers.'),(0,o.kt)("h3",{id:"heal-instruction"},"Heal Instruction"),(0,o.kt)("p",null,"Next, let's implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"heal")," instruction which allows a player to burn 1 token and restore their health to its maximum value."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"heal")," instruction requires the following accounts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player")," - the player executing the healing action"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player_data")," - the player data account storing the player\u2019s current health"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"player_token_account")," - the player's associated token account where the tokens will be burned"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"reward_token_mint")," - the token mint account, specifying the type of token that will be burned"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"token_program")," - required for interacting with instructions on the token program"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"associated_token_program")," - required when working with associated token accounts")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Burn token to health player\n    pub fn heal(ctx: Context<Heal>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            Burn {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                from: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.player.to_account_info(),\n            },\n        );\n\n        // Burn 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        burn(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct Heal<'info> {\n    #[account(mut)]\n    pub player: Signer<'info>,\n\n    #[account(\n        mut,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n\n    #[account(\n        mut,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b\"reward\"],\n        bump,\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n}\n")),(0,o.kt)("p",null,"The player's health is restored to its maximum value using the ",(0,o.kt)("inlineCode",{parentName:"p"},"heal")," instruction. The instruction then uses a cross-program invocation (CPI) to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"burn")," instruction from the Token program, which burns 1 token from the ",(0,o.kt)("inlineCode",{parentName:"p"},"player_token_account")," to heal the player."),(0,o.kt)("h3",{id:"build-and-deploy"},"Build and Deploy"),(0,o.kt)("p",null,"Great job! You've now completed the program! Go ahead and build and deploy it using the Solana Playground. Your final program should look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    metadata::{create_metadata_accounts_v3, CreateMetadataAccountsV3, Metadata},\n    token::{burn, mint_to, Burn, Mint, MintTo, Token, TokenAccount},\n};\nuse mpl_token_metadata::{pda::find_metadata_account, state::DataV2};\nuse solana_program::{pubkey, pubkey::Pubkey};\n\ndeclare_id!("CCLnXJAJYFjCHLCugpBCEQKrpiSApiRM4UxkBUHJRrv4");\n\nconst ADMIN_PUBKEY: Pubkey = pubkey!("REPLACE_WITH_YOUR_WALLET_PUBKEY");\nconst MAX_HEALTH: u8 = 100;\n\n#[program]\npub mod anchor_token {\n    use super::*;\n\n    // Create new token mint with PDA as mint authority\n    pub fn create_mint(\n        ctx: Context<CreateMint>,\n        uri: String,\n        name: String,\n        symbol: String,\n    ) -> Result<()> {\n        // PDA seeds and bump to "sign" for CPI\n        let seeds = b"reward";\n        let bump = *ctx.bumps.get("reward_token_mint").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // On-chain token metadata for the mint\n        let data_v2 = DataV2 {\n            name: name,\n            symbol: symbol,\n            uri: uri,\n            seller_fee_basis_points: 0,\n            creators: None,\n            collection: None,\n            uses: None,\n        };\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_metadata_program.to_account_info(),\n            CreateMetadataAccountsV3 {\n                metadata: ctx.accounts.metadata_account.to_account_info(), // the metadata account being created\n                mint: ctx.accounts.reward_token_mint.to_account_info(), // the mint account of the metadata account\n                mint_authority: ctx.accounts.reward_token_mint.to_account_info(), // the mint authority of the mint account\n                update_authority: ctx.accounts.reward_token_mint.to_account_info(), // the update authority of the metadata account\n                payer: ctx.accounts.admin.to_account_info(), // the payer for creating the metadata account\n                system_program: ctx.accounts.system_program.to_account_info(), // the system program account\n                rent: ctx.accounts.rent.to_account_info(), // the rent sysvar account\n            },\n            signer,\n        );\n\n        create_metadata_accounts_v3(\n            cpi_ctx, // cpi context\n            data_v2, // token metadata\n            true,    // is_mutable\n            true,    // update_authority_is_signer\n            None,    // collection details\n        )?;\n\n        Ok(())\n    }\n\n    // Create new player account\n    pub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n        Ok(())\n    }\n\n    // Mint tokens to player token account\n    pub fn kill_enemy(ctx: Context<KillEnemy>) -> Result<()> {\n        // Check if player has enough health\n        if ctx.accounts.player_data.health == 0 {\n            return err!(ErrorCode::NotEnoughHealth);\n        }\n        // Subtract 10 health from player\n        ctx.accounts.player_data.health = ctx.accounts.player_data.health.checked_sub(10).unwrap();\n\n        // PDA seeds and bump to "sign" for CPI\n        let seeds = b"reward";\n        let bump = *ctx.bumps.get("reward_token_mint").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                to: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.reward_token_mint.to_account_info(),\n            },\n            signer,\n        );\n\n        // Mint 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n\n    // Burn Token to health player\n    pub fn heal(ctx: Context<Heal>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            Burn {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                from: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.player.to_account_info(),\n            },\n        );\n\n        // Burn 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        burn(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMint<\'info> {\n    #[account(\n        mut,\n        address = ADMIN_PUBKEY\n    )]\n    pub admin: Signer<\'info>,\n\n    // The PDA is both the address of the mint account and the mint authority\n    #[account(\n        init,\n        seeds = [b"reward"],\n        bump,\n        payer = admin,\n        mint::decimals = 9,\n        mint::authority = reward_token_mint,\n\n    )]\n    pub reward_token_mint: Account<\'info, Mint>,\n\n    ///CHECK: Using "address" constraint to validate metadata account address\n    #[account(\n        mut,\n        address=find_metadata_account(&reward_token_mint.key()).0\n    )]\n    pub metadata_account: UncheckedAccount<\'info>,\n\n    pub token_program: Program<\'info, Token>,\n    pub token_metadata_program: Program<\'info, Metadata>,\n    pub system_program: Program<\'info, System>,\n    pub rent: Sysvar<\'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct InitPlayer<\'info> {\n    #[account(\n        init,\n        payer = player,\n        space = 8 + 8,\n        seeds = [b"player".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<\'info, PlayerData>,\n    #[account(mut)]\n    pub player: Signer<\'info>,\n    pub system_program: Program<\'info, System>,\n}\n\n#[derive(Accounts)]\npub struct KillEnemy<\'info> {\n    #[account(mut)]\n    pub player: Signer<\'info>,\n\n    #[account(\n        mut,\n        seeds = [b"player".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<\'info, PlayerData>,\n\n    // Initialize player token account if it doesn\'t exist\n    #[account(\n        init_if_needed,\n        payer = player,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<\'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b"reward"],\n        bump,\n    )]\n    pub reward_token_mint: Account<\'info, Mint>,\n\n    pub token_program: Program<\'info, Token>,\n    pub associated_token_program: Program<\'info, AssociatedToken>,\n    pub system_program: Program<\'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Heal<\'info> {\n    #[account(mut)]\n    pub player: Signer<\'info>,\n\n    #[account(\n        mut,\n        seeds = [b"player".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<\'info, PlayerData>,\n\n    #[account(\n        mut,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<\'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b"reward"],\n        bump,\n    )]\n    pub reward_token_mint: Account<\'info, Mint>,\n\n    pub token_program: Program<\'info, Token>,\n    pub associated_token_program: Program<\'info, AssociatedToken>,\n}\n\n#[account]\npub struct PlayerData {\n    pub health: u8,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg("Not enough health")]\n    NotEnoughHealth,\n}\n')),(0,o.kt)("h3",{id:"get-started-with-the-client"},"Get Started with the Client"),(0,o.kt)("p",null,"In this section, we'll walk you through a simple client-side implementation for interacting with the program. To get started, navigate to the ",(0,o.kt)("inlineCode",{parentName:"p"},"client.ts")," file in Solana Playground, remove the placeholder code, and add the code snippets from the following sections."),(0,o.kt)("p",null,"Start by adding the following code for the setup."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'import { Metaplex } from "@metaplex-foundation/js";\nimport { getMint, getAssociatedTokenAddressSync } from "@solana/spl-token";\n\n// metaplex token metadata program ID\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\n  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"\n);\n\n// metaplex setup\nconst metaplex = Metaplex.make(pg.connection);\n\n// token metadata\nconst metadata = {\n  uri: "https://raw.githubusercontent.com/solana-developers/program-examples/new-examples/tokens/tokens/.assets/spl-token.json",\n  name: "Solana Gold",\n  symbol: "GOLDSOL",\n};\n\n// reward token mint PDA\nconst [rewardTokenMintPda] = anchor.web3.PublicKey.findProgramAddressSync(\n  [Buffer.from("reward")],\n  pg.PROGRAM_ID\n);\n\n// player data account PDA\nconst [playerPDA] = anchor.web3.PublicKey.findProgramAddressSync(\n  [Buffer.from("player"), pg.wallet.publicKey.toBuffer()],\n  pg.PROGRAM_ID\n);\n\n// reward token mint metadata account address\nconst rewardTokenMintMetadataPDA = await metaplex\n  .nfts()\n  .pdas()\n  .metadata({ mint: rewardTokenMintPda });\n\n// player token account address\nconst playerTokenAccount = getAssociatedTokenAddressSync(\n  rewardTokenMintPda,\n  pg.wallet.publicKey\n);\n')),(0,o.kt)("p",null,"Next, add the following two helper functions.  These functions will be used to confirm transactions and fetch account data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'async function logTransaction(txHash) {\n  const { blockhash, lastValidBlockHeight } =\n    await pg.connection.getLatestBlockhash();\n\n  await pg.connection.confirmTransaction({\n    blockhash,\n    lastValidBlockHeight,\n    signature: txHash,\n  });\n\n  console.log(`Use \'solana confirm -v ${txHash}\' to see the logs`);\n}\n\nasync function fetchAccountData() {\n  const [playerBalance, playerData] = await Promise.all([\n    pg.connection.getTokenAccountBalance(playerTokenAccount),\n    pg.program.account.playerData.fetch(playerPDA),\n  ]);\n\n  console.log("Player Token Balance: ", playerBalance.value.uiAmount);\n  console.log("Player Health: ", playerData.health);\n}\n')),(0,o.kt)("p",null,"Next, invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMint")," instruction to create a new token mint if it does not already exist."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'let txHash;\n\ntry {\n  const mintData = await getMint(pg.connection, rewardTokenMintPda);\n  console.log("Mint Already Exists");\n} catch {\n  txHash = await pg.program.methods\n    .createMint(metadata.uri, metadata.name, metadata.symbol)\n    .accounts({\n      rewardTokenMint: rewardTokenMintPda,\n      metadataAccount: rewardTokenMintMetadataPDA,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n    })\n    .rpc();\n  await logTransaction(txHash);\n}\nconsole.log("Token Mint: ", rewardTokenMintPda.toString());\n')),(0,o.kt)("p",null,"Next, call the ",(0,o.kt)("inlineCode",{parentName:"p"},"initPlayer")," instruction to create a new player account if one does not already exist."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'try {\n  const playerData = await pg.program.account.playerData.fetch(playerPDA);\n  console.log("Player Already Exists");\n  console.log("Player Health: ", playerData.health);\n} catch {\n  txHash = await pg.program.methods\n    .initPlayer()\n    .accounts({\n      playerData: playerPDA,\n      player: pg.wallet.publicKey,\n    })\n    .rpc();\n  await logTransaction(txHash);\n  console.log("Player Account Created");\n}\n')),(0,o.kt)("p",null,"Next, invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"killEnemy")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'txHash = await pg.program.methods\n  .killEnemy()\n  .accounts({\n    playerData: playerPDA,\n    playerTokenAccount: playerTokenAccount,\n    rewardTokenMint: rewardTokenMintPda,\n  })\n  .rpc();\nawait logTransaction(txHash);\nconsole.log("Enemy Defeated");\nawait fetchAccountData();\n')),(0,o.kt)("p",null,"Next, invoke the ",(0,o.kt)("inlineCode",{parentName:"p"},"heal")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'txHash = await pg.program.methods\n  .heal()\n  .accounts({\n    playerData: playerPDA,\n    playerTokenAccount: playerTokenAccount,\n    rewardTokenMint: rewardTokenMintPda,\n  })\n  .rpc();\nawait logTransaction(txHash);\nconsole.log("Player Healed");\nawait fetchAccountData();\n')),(0,o.kt)("p",null,"Finally, run the client by clicking the \u201cRun\u201d button in Solana Playground. You can copy the Token Mint address printed to the console and verify on Solana Explorer that the token now has metadata. The output should be similar to the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Running client...\n  client.ts:\n    Use 'solana confirm -v 3AWnpt2Wy6jQckue4QeKsgDNKhKkhpewPmRtxvJpzxGgvK9XK9KEpTiUzAQ5vSC6CUoUjc6xWZCtrihVrFy8sACC' to see the logs\n    Token Mint:  3eS7hdyeVX5g8JGhn3Z7qFXJaewoJ8hzgvubovQsPm4S\n    Use 'solana confirm -v 63jbBr5U4LG75TiiHfz65q7yKJfHDhGP2ocCiDat5M2k4cWtUMAx9sHvxhnEguLDKXMbDUQKUt1nhvyQkXoDhxst' to see the logs\n    Player Account Created\n    Use 'solana confirm -v 2ziK41WLoxfEHvtUgc5c1SyKCAr5FvAS54ARBJrjqh9GDwzYqu7qWCwHJCgMZyFEVovYK5nUZhDRHPTMrTjq1Mm6' to see the logs\n    Enemy Defeated\n    Player Token Balance:  1\n    Player Health:  90\n    Use 'solana confirm -v 2QoAH22Q3xXz9t2TYRycQMqpEmauaRvmUfZ7ZNKUEoUyHWqpjW972VD3eZyeJrXsviaiCC3g6TE54oKmKbFQf2Q7' to see the logs\n    Player Healed\n    Player Token Balance:  0\n    Player Health:  100\n")))}m.isMDXComponent=!0}}]);