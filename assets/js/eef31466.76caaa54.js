"use strict";(self.webpackChunkall_in_one_solana=self.webpackChunkall_in_one_solana||[]).push([[7256],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=o,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||r;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},88121:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const r={title:"Cross Program Invocations (CPIs)",sidebar_position:7,tags:["solana-cook-book","cpi"]},i="Cross Program Invocations (CPIs)",s={unversionedId:"core-concepts/cpi",id:"core-concepts/cpi",title:"Cross Program Invocations (CPIs)",description:"A Cross-Program Invocation (CPI) is a direct call from one program into another, allowing for the composability of Solana programs. Just as any client can call any program using the JSON RPC, any program can call any other program via a CPI. CPIs essentially turn the entire Solana ecosystem into one giant API that is at your disposal as a developer.",source:"@site/docs/cookbook-zh/core-concepts/cpi.md",sourceDirName:"core-concepts",slug:"/core-concepts/cpi",permalink:"/cookbook-zh/core-concepts/cpi",draft:!1,editUrl:"https://github.com/CreatorsDAO/all-in-one-solana/tree/main/docs/cookbook-zh/core-concepts/cpi.md",tags:[{label:"solana-cook-book",permalink:"/cookbook-zh/tags/solana-cook-book"},{label:"cpi",permalink:"/cookbook-zh/tags/cpi"}],version:"current",lastUpdatedBy:"Davirain",lastUpdatedAt:1695967092,formattedLastUpdatedAt:"Sep 29, 2023",sidebarPosition:7,frontMatter:{title:"Cross Program Invocations (CPIs)",sidebar_position:7,tags:["solana-cook-book","cpi"]},sidebar:"tutorialSidebar",previous:{title:"\u4ea4\u6613",permalink:"/cookbook-zh/core-concepts/transactions"},next:{title:"\u6307\u5357",permalink:"/cookbook-zh/guides/"}},l={},c=[{value:"Deep Dive",id:"deep-dive",level:2},{value:"CPI with\xa0<code>invoke</code>",id:"cpi-withinvoke",level:3},{value:"CPI with\xa0<code>invoke_signed</code>",id:"cpi-withinvoke_signed",level:3},{value:"CPI <code>Instruction</code>",id:"cpi-instruction",level:3},{value:"CPI <code>AccountInfo</code>",id:"cpi-accountinfo",level:3},{value:"Other Resources",id:"other-resources",level:2}],p={toc:c},u="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"cross-program-invocations-cpis"},"Cross Program Invocations (CPIs)"),(0,o.kt)("p",null,"A Cross-Program Invocation (CPI) is a direct call from one program into another, allowing for the composability of Solana programs. Just as any client can call any program using the JSON RPC, any program can call any other program via a CPI. CPIs essentially turn the entire Solana ecosystem into one giant API that is at your disposal as a developer."),(0,o.kt)("p",null,"The purpose of this section is to provide a high-level overview CPIs. Please refer to the linked resources below for more detailed explanations, examples, and walkthroughs."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"tip Fact Sheet")),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"A\xa0Cross-Program Invocation (CPI)\xa0is a call from one program to another, targeting a specific instruction on the program being called"),(0,o.kt)("li",{parentName:"ul"},"CPIs allow the calling program to extend its signer privileges to the callee program"),(0,o.kt)("li",{parentName:"ul"},"Programs can execute CPIs using either ",(0,o.kt)("inlineCode",{parentName:"li"},"invoke")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"invoke_signed")," within their instructions"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"invoke")," is used when all required signatures are accessible prior to invocation, without the need for PDAs to act as signers"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"invoke_signed")," is used when PDAs from the calling program are required as signers in the CPI"),(0,o.kt)("li",{parentName:"ul"},"After a CPI is made to another program, the callee program can make further CPIs to other programs, up to a maximum depth of 4"))),(0,o.kt)("h2",{id:"deep-dive"},"Deep Dive"),(0,o.kt)("p",null,"Cross Program Invocations (CPIs) enable the composability of Solana programs, which allow developers to utilize and build on the instruction of existing programs."),(0,o.kt)("p",null,"To execute CPIs, use the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/solana-program/latest/solana_program/program/fn.invoke.html"},"invoke")," or ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/solana-program/latest/solana_program/program/fn.invoke_signed.html"},"invoke_signed")," function found in the ",(0,o.kt)("inlineCode",{parentName:"p"},"solana_program")," crate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// Used when there are not signatures for PDAs needed\npub fn invoke(\n    instruction: &Instruction,\n    account_infos: &[AccountInfo<'_>]\n) -> ProgramResult\n\n// Used when a program must provide a 'signature' for a PDA, hence the signer_seeds parameter\npub fn invoke_signed(\n    instruction: &Instruction,\n    account_infos: &[AccountInfo<'_>],\n    signers_seeds: &[&[&[u8]]]\n) -> ProgramResult\n")),(0,o.kt)("p",null,"To make a CPI, you must specify and construct an instruction on the program being invoked and supply a list of accounts necessary for that instruction. If a PDA is required as a signer, the ",(0,o.kt)("inlineCode",{parentName:"p"},"signers_seeds")," must also be provided when using ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke_signed"),"."),(0,o.kt)("h3",{id:"cpi-withinvoke"},"CPI with\xa0",(0,o.kt)("inlineCode",{parentName:"h3"},"invoke")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke")," function is used when making a CPI that does not require any PDAs to act as signers. When making CPIs, the Solana runtime extends the original signature passed into a program to the callee program."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"invoke(\n    &some_instruction,                           // instruction to invoke\n    &[account_one.clone(), account_two.clone()], // accounts required by instruction\n)?;\n")),(0,o.kt)("h3",{id:"cpi-withinvoke_signed"},"CPI with\xa0",(0,o.kt)("inlineCode",{parentName:"h3"},"invoke_signed")),(0,o.kt)("p",null,"To make a CPI that requires a PDA as a signer, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke_signed")," function and provide the necessary seeds to derive the required PDA of the calling program."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"invoke_signed(\n    &some_instruction,                   // instruction to invoke\n    &[account_one.clone(), pda.clone()], // accounts required by instruction, where one is a pda required as signer\n    &[signers_seeds],                    // seeds to derive pda\n)?;\n")),(0,o.kt)("p",null,"While PDAs have no private keys of their own, they can still act as a signer in an instruction via a CPI. To verify that a PDA belongs to the calling program, the seeds used to generate the PDA required as a signer must be included in as ",(0,o.kt)("inlineCode",{parentName:"p"},"signers_seeds"),"."),(0,o.kt)("p",null,"The Solana runtime will internally call\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"create_program_address"),"\xa0using the seeds provided and the\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"program_id"),"\xa0of the calling program. The resulting PDA is then compared to the addresses supplied in the instruction. If there's a match, the PDA is considered a valid signer."),(0,o.kt)("h3",{id:"cpi-instruction"},"CPI ",(0,o.kt)("inlineCode",{parentName:"h3"},"Instruction")),(0,o.kt)("p",null,"Depending on the program you're making the call to, there may be a crate available with helper functions for creating the\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"Instruction"),". Many individuals and organizations create publicly available crates alongside their programs that expose these sorts of functions to simplify calling their programs."),(0,o.kt)("p",null,"The definition of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Instruction")," type required for a CPI includes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"program_id"),"\xa0- the public key of the program that executes the instruction"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"accounts"),"\xa0- a list of all accounts that may be read or written to during the execution of the instruction"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"data"),"\xa0-  the instruction data required by the instruction")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Instruction {\n    pub program_id: Pubkey,\n    pub accounts: Vec<AccountMeta>,\n    pub data: Vec<u8>,\n}\n")),(0,o.kt)("p",null,"The\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"AccountMeta"),"\xa0struct has the following definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct AccountMeta {\n    pub pubkey: Pubkey,\n    pub is_signer: bool,\n    pub is_writable: bool,\n}\n")),(0,o.kt)("p",null,"When creating a CPI, use the following syntax to specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountMeta")," for each account:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AccountMeta::new"),"\xa0- indicates writable"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"AccountMeta::new_readonly"),"\xa0- indicates\xa0",(0,o.kt)("em",{parentName:"li"},"not"),"\xa0writable"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(pubkey, true)"),"\xa0- indicates account is signer"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(pubkey, false)"),"\xa0- indicates account is\xa0",(0,o.kt)("em",{parentName:"li"},"not"),"\xa0signer")),(0,o.kt)("p",null,"Here is an example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"use solana_program::instruction::AccountMeta;\n\nlet account_metas = vec![\n    AccountMeta::new(account1_pubkey, true),\n    AccountMeta::new(account2_pubkey, false),\n    AccountMeta::new_readonly(account3_pubkey, false),\n    AccountMeta::new_readonly(account4_pubkey, true),\n]\n")),(0,o.kt)("h3",{id:"cpi-accountinfo"},"CPI ",(0,o.kt)("inlineCode",{parentName:"h3"},"AccountInfo")),(0,o.kt)("p",null,"To use ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"invoke_signed"),", a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"account_infos")," is also required. Similar to the list of ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountMeta")," in the instruction, you need to include all the ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountInfo")," of each account that the program you're calling will read from or write to."),(0,o.kt)("p",null,"For reference, the ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountInfo")," struct has the following definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"/// Account information\n#[derive(Clone)]\npub struct AccountInfo<'a> {\n    /// Public key of the account\n    pub key: &'a Pubkey,\n    /// Was the transaction signed by this account's public key?\n    pub is_signer: bool,\n    /// Is the account writable?\n    pub is_writable: bool,\n    /// The lamports in the account.  Modifiable by programs.\n    pub lamports: Rc<RefCell<&'a mut u64>>,\n    /// The data held in this account.  Modifiable by programs.\n    pub data: Rc<RefCell<&'a mut [u8]>>,\n    /// Program that owns this account\n    pub owner: &'a Pubkey,\n    /// This account's data contains a loaded program (and is now read-only)\n    pub executable: bool,\n    /// The epoch at which this account will next owe rent\n    pub rent_epoch: Epoch,\n}\n")),(0,o.kt)("p",null,"You can create a copy of the ",(0,o.kt)("inlineCode",{parentName:"p"},"AccountInfo")," for each required account using the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html#impl-Clone-for-AccountInfo%3C'a%3E"},"Clone")," trait, which is implemented for the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/solana-program/latest/solana_program/account_info/struct.AccountInfo.html"},"AccountInfo")," struct in the ",(0,o.kt)("inlineCode",{parentName:"p"},"solana_program")," crate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let accounts_infos = [\n    account_one.clone(),\n    account_two.clone(),\n    account_three.clone(),\n];\n")),(0,o.kt)("p",null,"While this section has provided a high-level overview of CPIs, more detailed explanations, examples, and walkthroughs can be found in the linked resources below."),(0,o.kt)("h2",{id:"other-resources"},"Other Resources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.solana.com/developing/programming-model/calling-between-programs#cross-program-invocations"},"Official Documentation")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://solanacookbook.com/references/programs.html#how-to-do-cross-program-invocation"},"Solana Cookbook Reference")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://www.soldev.app/course/cpi"},"Solana Course Native CPI Lesson")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://www.soldev.app/course/anchor-cpi"},"Solana Course Anchor CPI Lesson")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/solana-developers/program-examples/tree/main/basics/cross-program-invocation"},"Solana Developers Program Examples"))))}m.isMDXComponent=!0}}]);